---
title: "Setup-new-aoi"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Setup-new-aoi}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## 1. Setting up a new PEM project 

The PEMr package is designed to help users access the functions and follow a workflow to create a Predictive Ecosystem Map project. 

These packages are currently in development and there maybe breaking changes. 

The first step needed is to generate a new PEM project. This will include a new R-studio project, a template folder structure, and a series of template workflow quarto documents. 


```{r}
#| eval: false
remotes::install_github("ninoxconsulting/PEMr", build_vignettes = TRUE)
remotes::install_github("ninoxconsulting/PEMprepr", build_vignettes = TRUE)

library(PEMr)
library(PEMprepr)

```

The first step is to decide the name of your area of interest (AOI) and if you have a spatial file for the given area. This is not required at this stage but if a convenient feature. 


```{r}
#| eval: false
#| 
create_pemr_project(
  path = "C:\\r_repo\\2024_pemr\\testing_pemr",
  aoi = "datecreek_aoi",
  aoi_file = "C:\\r_repo\\2024_pemr\\datecreek_aoi.gpkg"
)


```


## 2. Generating base data for modelling (5m resolution as default) 


```{r setup, eval = FALSE}
library(PEMr)
library(PEMprepr)

#project_name <- "{{ aoi_name }}"
#project_name <- "datecreek_aoi"

fid <- read_fid()

```


### create model templates 

```{r, eval = FALSE}

aoi_dir = read_fid()$dir_0010_vector$path_abs
files <- list.files(aoi_dir, pattern = "([.]gpkg)|([.]shp)$")
aoi_file = fs::path(aoi_dir, files )


# vector
aoi <- snap_aoi(aoi_file, method = "expand")

aoi <- fs::path(PEMprepr::read_fid()$dir_1010_vector$path_abs, "aoi_snapped.gpkg")

# raster

# Prepare Raster Data(for 5m lidar template)

r5 <- create_template_raster(aoi, res = 5)

```


### generate base vector layers

```{r, eval = FALSE}

create_base_vectors(aoi, out_dir = PEMprepr::read_fid()$dir_1010_vector$path_abs)

```


### generate base DEM layer for modelling (5m)

```{r, eval = FALSE}

#1) option to use trim data 

dem = get_cded_dem(aoi = fs::path(PEMprepr::read_fid()$dir_1020_covariates$path_abs, "25m", "template.tif"),
                   res = 5,
                   overwrite = TRUE)

#2) option to use lidr 

```

### generate raster covariates for modelling (5m)


```{r, eval = FALSE}

# get model covariates 

find_saga_path()

saga_cmd()


create_covariates(
   dtm = fs::path(PEMprepr::read_fid()$dir_1020_covariates$path_rel,"5m","dem.tif"),
   saga_path = saga_cmd()
   out_dir = PEMprepr::read_fid()$dir_1020_covariates$path_rel,
   layers = "all"
)


```


### Create a bec raster to match the template sizes 

```{r, eval = FALSE}
# generate a 5m raster
bec_rast5 <- create_bgc_template(
  field = "MAP_LABEL",
  template =  r5,
  write_output = FALSE
)


```


congratulations you are now ready to start developing the sample plan









## 3. Generating landscape data for sample plan development (25m resolution as default) 


## The workflow of samplr is still in developement and likely to change.


```{r, eval = FALSE}

# vector (aoi, roads and start points)

in_dir = PEMprepr::read_fid()$dir_1010_vector$path_abs
aoi_file = fs::path(in_dir, "aoi_snapped.gpkg" )

out_dir <- PEMprepr::read_fid()$dir_201010_inputs$path_abs


aoils <- snap_aoi(aoi_file, method = "expand", buffer = 1000, write_output = FALSE)

sf::st_write(aoils, fs::path(out_dir, "aoi_snapped_ls.gpkg"), append = FALSE)



# Prepare Raster Data (for landscape)

r25 <- create_template_raster(aoils,
                              res = 25,
                              out_dir = PEMprepr::read_fid()$dir_201010_inputs$path_abs,
                              write_output = TRUE)


dem25 = get_cded_dem(aoi = r25,
                     res = 25,
                     out_dir = PEMprepr::read_fid()$dir_201010_inputs$path_abs,
                     write_output = TRUE)



# generate a 25m raster

bec_rast25 <- create_bgc_template(
  field = "MAP_LABEL",
  template=  r25,
  out_dir = PEMprepr::read_fid()$dir_201010_inputs$path_abs,
  write_output = TRUE
)



# Generate landscape covariates

create_landscape_covariates(
  dtm = dem25,
  saga_path = saga_cmd(),
  layers = c("mrvbf", "dah", "landform"),
  out_dir = PEMprepr::read_fid()$dir_201010_inputs$path_abs,
  sieve_size = 10,
  dah_threshold = 0.2,
  saga_param = list(
    T_SLOPE = 64, TPCTL_V = 6, T_PCTL_R = 2,
    P_SLOPE = 4.0, P_PCTL = 3.0, UPDATE = 1,
    CLASSIFY = 1, MAX_RES = 100
  ))



# create binned landscape
landscapes <- create_binned_landscape(
  in_dir = fs::path(PEMprepr::read_fid()$dir_201010_inputs$path_abs,"25m","modules_landscape"),
  layers = c("dah_LS", "landform_LS","mrvbf_LS"),
  write_output = TRUE)

terra::plot(landscapes)


# check landscape class with Bec
routdf <- check_bgc_landscapes(bec_rast25, landscapes)

ggplot2::ggplot(routdf, ggplot2::aes(landscape)) +
  ggplot2::geom_histogram() +
  ggplot2::facet_wrap(~MAP_LABEL)


# download roads layer and run through standard checks

out_dir <- PEMprepr::read_fid()$dir_201010_inputs$path_abs

roadsls <- get_roads(aoils, out_dir)

check_roads(roadsls)






# Get start points and run checks

cities <- sf::st_read(fs::path(PEMprepr::read_fid()$dir_1010_vector$path_rel,"major_towns_bc.gpkg"))

loc <- data.frame(NAME = "TEST_location",
                  X = 889571,
                  Y = 1157078)

loc <- st_as_sf(loc,
                coords = c("X", "Y"),
                crs = 3005)

sf::st_geometry(loc)<- "geom"
cities <- dplyr::bind_rows(cities, loc)

# in study area
nearest_town = "TEST_location"
start <- cities[cities$NAME == nearest_town,"NAME"]

check_locations( roads = roadsls, locations = start)

sf::st_write(start, fs::path(out_dir, "start.gpkg"), append = FALSE)


## Generate the cost layer - need to review these two scripts and decided which method to use. 
## These can be run as stand alone scripts and are located here: 

#https://github.com/ninoxconsulting/PEMsamplr/blob/create_sampleplan/R/placeholder_prep_cost_layer_old.R


## Currently there are two options
## old version
#03_sample_plan_new_version.R

## new version
#03_sample_plan_new_version.R
#fn_prep_cost_layer_utils.R

```


# Generate sample plan inputs  

This section of codes generates all the required inputs to build the sample plan. 
The final step is to compile into a single folder. 

```{r eval = FALSE}

# define the input directories
sampleplan_dir <- PEMprepr::read_fid()$dir_201010_inputs$path_rel

#read in cost layer
# note this points to the old sample plan version created by placeholder script
acost <- terra::rast(fs::path(sampleplan_dir, "acost.tif" ))

# read in input layers
bec = terra::rast(fs::path(PEMprepr::read_fid()$dir_201010_inputs$path_rel, "25m", "bec.tif"))
binned_landscape = terra::rast(fs::path(PEMprepr::read_fid()$dir_201010_inputs$path_rel, "25m", "modules", "landscape_binned.tif"))
acost <- terra::rast(fs::path(sampleplan_dir, "acost.tif" ))


# check how the costs are distributed across BEC zones to determine viability 
ck <- classify_bgc_cost( bec, binned_landscape, acost)

ggplot2::ggplot(ck, ggplot2::aes(landscape, fill = cost_code)) +
  ggplot2::geom_histogram(bins = 30) +
  ggplot2::facet_wrap(~MAP_LABEL)




# generate cost penalty
# assigns a higher cost to areas with various criteria

vec_dir = fs::path(PEMprepr::read_fid()$dir_1010_vector$path_rel)
dem = terra::rast(fs::path(PEMprepr::read_fid()$dir_201010_inputs$path_rel, "25m", "dem.tif"))
cost =  acost
costval = 3000
vri_cost = 2500
calc_by_qq = TRUE


cost_penalty <- create_cost_penalty(vec_dir = vec_dir,
                                    cost = acost,
                                    dem = dem,
                                    costval = 3000,
                                    vri_cost = 2500,
                                    calc_by_qq = TRUE,
                                    write_output = FALSE)



terra::plot(cost_penalty)

# create no sample areas
# detemines the areas where samples will be excluded

cost_masked <- create_cost_exclusion(vec_dir = vec_dir,
                                     cost = cost_penalty,
                                     buffer = 150,
                                     write_output = FALSE)


terra::writeRaster(cost_masked,
                   fs::path(PEMprepr::read_fid()$dir_201010_inputs$path_rel,
                            "cost_final.tif"), overwrite = TRUE)


# generate a BGC cost mask per BGC in map area

out_dir <- fs::path(PEMprepr::read_fid()$dir_2010_standard$path_rel, "20_masks")
cost_masked <- terra::rast(fs::path(sampleplan_dir, "cost_final.tif" ))
vec_dir = fs::path(PEMprepr::read_fid()$dir_1010_vector$path_rel)


create_bgc_mask(vec_dir, cost_masked, out_dir = exclusion_path)




# Move files to the same folder (Note this might be redundant if needed)

root_path <- fs::path(PEMprepr::read_fid()$dir_201010_inputs$path_rel)

move_files <- function(root_path){

  ftm <- fs::dir_ls(root_path,recurse = T, regexp = ".tif$")

  for (i in ftm){
    # i = ftm[1]

    finame <- basename(i)
    froot <-  basename(fs::dir_ls(root_path, recurse = F, regexp = ".tif$"))

    if(finame %in% froot) {
      cli::cli_alert_success(
        " {.val finame}. skipped "
      )
    } else {

      fnew <- fs::path(root_path, finame)
      fmove <- fs::file_move(i, fnew)
      cli::cli_alert_success(
        " {.val i}. moved to  "
      )
    }
  }

}

move_files(root_path)


```

### congratulations you are now ready to start developing the sample plan ! 






# Generate a sample plan

```{r eval = FALSE}

#remotes::install_github("ninoxconsulting/PEMprepr")
library(PEMprepr)

remotes::install_github("ninoxconsulting/PEMsamplr", ref = "create_sampleplan")
library(PEMsamplr)

#devtools::install_github("kdaust/clhs")
library(clhs)

# define the location of input layers used in the latin hyper cube sampling
landscape_dir <- fs::path(PEMprepr::read_fid()$dir_201010_inputs$path_rel)

# define the location of the output clhs points
clhs_out_dir <- PEMprepr::read_fid()$dir_20103010_clhs$path_rel

# stack the layers and convert to factor
fileoi <- c("dah_LS.tif", "mrvbf_LS.tif", "landform_LS.tif")
filesoi <- list.files(landscape_dir, full.names = TRUE)[list.files(landscape_dir) %in% fileoi]

all_cov <- terra::rast(filesoi)
all_cov <- terra::as.factor(all_cov)
terra::is.factor(all_cov)

# add cost layer 
cost <- terra::rast(fs::path(landscape_dir, "cost_final.tif"))
all_cov<- c(all_cov, cost)

# check that the cavariates are factors (not needed for cost layer)
terra::is.factor(all_cov)


# read in bec data and loop through each bec zone to generate clhs sample plans

bec_dir = fs::path(PEMprepr::read_fid()$dir_201020_masks$path_rel)

boi <- list.files(bec_dir, pattern = ".tif")
#subset only some files from list
#boi <- boi[c(2,5,6)]

for(b in boi) {
  #b <- boi[1]
  boi_mask <- terra::rast(file.path(bec_dir, b))
  names(boi_mask) = "mask"
  bname <- gsub("_exclude_mask.tif", "", b)

  sample_layers_masked <- c(all_cov, boi_mask) |>
    terra::mask(boi_mask)
  sample_layers_masked <- sample_layers_masked[[1:4]]

 # terra::writeRaster(sample_layers_masked, fs::path(clhs_out_dir, paste0(bname,"_clhs_sample_mask.tif")), overwrite = TRUE)

  # create replicate number of different clhs sample plans
  
  for(rot in 1:5){
   #rot = 1
    sample_points <- create_clhs(all_cov = sample_layers_masked,
                                 num_slices = 5,
                                 to_include = NULL,
                                 n_points = 5 ,
                                 min_dist = 900,
                                 num_sample = 5000000)

    sample_points <- dplyr::mutate(sample_points, bgc = bname)
    fname <- paste0(bname,"_clhs_sample_",rot,".gpkg")
    sf::st_write(sample_points, file.path(clhs_out_dir, fname), append=FALSE, quite = TRUE)

  }

}


# Once the sample plan are generated we can review the comparative costs and
# plot each replicate per BEC zone 

plot_clhs_cost(clhs_out_dir)

# After a review, we need to select a sample plan for each BEC zone. This is 
# usually the plan with the lowest cost. This will be the input to generate the 
# full sample plan. 

clhs_out_dir <- PEMprepr::read_fid()$dir_20103010_clhs$path_rel

# two examples of potential clhs sets to use for full sample plan 

clhs_set <- "ICHmc2_clhs_sample_3.gpkg"
#clhs_set <- c("ICHmc2_clhs_sample_3.gpkg", "ICHmc1_clhs_sample_3.gpkg")

# generate sample plan (spatial file) and sample plan (csv)
create_sampleplan(clhs_set)


```


### congratulations you are now ready to go in the field and start sampling!





# Post Fieldwork data processing 

```{r, eval = FALSE}

# read in the raw field data and prepare it for PEM analysis

# note this section is still in development branch 
remotes::install_github("ninoxconsulting/PEMsamplr", ref = "create_sampleplan_sub")
library(PEMsamplr)


# set up folder paths

# location of final s1_sample plan / gpkg + where transect_layout will reside
#input_file <- fs::path(PEMprepr::read_fid()$dir_20104020_transect$path_abs, "s1_sampling.gpkg")
input_path <- PEMprepr::read_fid()$dir_20104020_transect$path_rel

# location where the final simplified transect layer will be stored
out_dir = PEMprepr::read_fid()$dir_201040_plan_final$path_rel




# generate simple transect plan layer
transect_layout <- simplify_transectlayout(input_path, 
                                           out_dir, 
                                           write_output = FALSE, 
                                           overwrite = FALSE)


# for test aoi - prepared field data

# read in the prepped transect layout and buffer
transect_layout <- sf::st_read(fs::path(out_dir, "transect_layout_date_creek_demo.gpkg"))






##### process Raw field data 

# location of the raw field data
rawdat <- PEMprepr::read_fid()$dir_20105010_raw_field_data$path_rel

#location where cleaned data will be stored
cleandat <- PEMprepr::read_fid()$dir_20105020_clean_field_data$path_rel


# import and clean field data
points <- format_fielddata(rawdat,
  transect_layout,
  buffer = 10,
  write_output = TRUE,
  out_dir = fs::path(PEMprepr::read_fid()$dir_20105020_clean_field_data$path_rel),
  out_name = "s1_points_raw.gpkg"
)


# format tracklog (optional)
tracks <- format_tracklog(rawdat,
  transect_layout,
  buffer = 10,
  write_output = TRUE,
  out_dir = fs::path(PEMprepr::read_fid()$dir_20105020_clean_field_data$path_rel),
  out_name = "s1_track_raw.gpkg"
)



# check and clean up field data names
key <- generate_mapkey(
  data_pts  = fs::path(PEMprepr::read_fid()$dir_20105020_clean_field_data$path_rel, "s1_points_raw.gpkg"),
  write_output = TRUE,
  out_dir = fs::path(PEMprepr::read_fid()$dir_3010_inputs$path_rel),
  out_name = "mapunitkey.csv"
)



# Manually review the generated basemap key file (mapunit.key) and add missing
# basemapunit calls if needed.



# convert the points data to cleaned points to line segments
processed_transects <- make_lines(
  points = points,
  transect_layout = transect_layout,
  method = "pts2lines",
  buffer = 20,
  write_output = TRUE,
  out_dir = fs::path(PEMprepr::read_fid()$dir_20105020_clean_field_data$path_rel),
  out_name = "proc_s1_transects5.gpkg"
)


# convert pt to lines (2 options here)
# 1. convert points to lines - no neighbours
processed_pts <- convert_lines_pts(
  processed_lines = processed_transects,
  buffer = 2.5,
  neighbours = FALSE,
  trast = fs::path(PEMprepr::read_fid()$dir_1020_covariates$path_rel, "5m", "template.tif"),
  write_output = TRUE,
  out_dir = PEMprepr::read_fid()$dir_20105020_clean_field_data$path_rel,
  out_name = "allpoints.gpkg"
)

#2. convert points to lines - with neighbours

pp <- convert_lines_pts(
  processed_lines = processed_transects,
  buffer = 2.5,
  neighbours = TRUE,
  trast = fs::path(PEMprepr::read_fid()$dir_1020_covariates$path_rel, "5m", "template.tif"),
  write_output = FALSE,
  out_dir = PEMprepr::read_fid()$dir_20105020_clean_field_data$path_rel,
  out_name = "allpoints_n.gpkg"
)


# attribute the points with covariates

att_pts <- attribute_points(
  data_pts = processed_pts,
  cov_dir = fs::path(PEMprepr::read_fid()$dir_1020_covariates$path_rel, "5m"),
  write_output = FALSE,
  out_dir = fs::path(PEMprepr::read_fid()$dir_20105030_attributed_field_data$path_rel),
  out_name = "allpoints_att.gpkg")



```

## Congratulations you are now ready to start modelling


